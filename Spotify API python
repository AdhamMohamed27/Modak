from flask import Flask, redirect, url_for, session, request, render_template
import os
import requests
from dotenv import load_dotenv
import base64
# datetime library to convert the ISO 8601 timestamp to a more readable format before passing it to the template.
from datetime import datetime 



# Load environment variables
load_dotenv()


# Error handling 
# print("CLIENT ID:", os.getenv("SPOTIFY_CLIENT_ID"))
# print("CLIENT Secret:", os.getenv("SPOTIFY_CLIENT_SECRET"))
# print("url:", os.getenv("SPOTIFY_REDIRECT_URI"))



# The secret_key is what makes sure this data is secure and can’t be tampered with.
# Think of the secret_key as a unique password that only the server knows, which it uses to encrypt and verify data sent to users’ browsers. 
app = Flask(__name__)
app.secret_key = os.urandom(24)  # Generates a random 24-byte secret key each time
CLIENT_ID = os.getenv("SPOTIFY_CLIENT_ID")
REDIRECT_URI = os.getenv("SPOTIFY_REDIRECT_URI")
CLIENT_SECRET = os.getenv("SPOTIFY_CLIENT_SECRET")




# This route doesn’t do much on its own; it immediately redirects users to the /login route. Essentially, it serves as a starting point that directs users to the login process.
@app.route('/')
def home():
    return redirect(url_for('login'))


# This route starts the Spotify authentication process. It creates an authorization URL with the necessary scopes, client ID, and redirect URI, 
# and then redirects the user to Spotify’s authorization page.
@app.route('/login')
def login():
    scope = "user-read-private user-read-email user-top-read user-read-recently-played user-library-read playlist-modify-public playlist-modify-private"
    auth_url = (
        f"https://accounts.spotify.com/authorize"
        f"?response_type=code&client_id={CLIENT_ID}"
        f"&redirect_uri={REDIRECT_URI}"
        f"&scope={scope}"
    )
    return redirect(auth_url)


# When the user is redirected back to the /callback endpoint after authorizing the app on Spotify, Spotify sends an authorization code as a query parameter. 
# This code is extracted using request.args.get("code").

@app.route('/callback')
def callback():
    code = request.args.get("code")
    token_url = "https://accounts.spotify.com/api/token"
    
    # Base64-encoded authorization header with Client ID and Client Secret
    auth_header = base64.b64encode(f"{CLIENT_ID}:{CLIENT_SECRET}".encode()).decode()
    
    headers = {
        "Authorization": f"Basic {auth_header}",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    data = {
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": REDIRECT_URI
    }
    
    # Send POST request to get the access token and refresh token
    response = requests.post(token_url, headers=headers, data=data)
    response_data = response.json()
    
    # Store access and refresh tokens in session
    session["access_token"] = response_data.get("access_token")
    session["refresh_token"] = response_data.get("refresh_token")

    print("Access Token:", session.get("access_token"))
    print("Refresh Token:", session.get("refresh_token"))

    
# After successfully storing the tokens, the user is redirected to the /dashboard endpoint to view their personalized dashboard.

    return redirect(url_for("dashboard"))


# The function first checks if there’s an access_token stored in the session. 
# If the access token isn’t found, it means the user hasn’t authorized the app yet, so it redirects them to the /login route to start the authentication process.

@app.route('/dashboard')
def dashboard():

    access_token = session.get("access_token")
    if not access_token:
        return redirect(url_for("login"))

    headers = {"Authorization": f"Bearer {access_token}"}

    # Retrieve User's Profile Information
    response_user = requests.get("https://api.spotify.com/v1/me", headers=headers)
    if response_user.status_code == 200:
        user_info = response_user.json()
        user_data = {
            "display_name": user_info['display_name'],
            "profile_image": user_info['images'][0]['url'] if user_info['images'] else None,
            "followers": user_info['followers']['total'],
            "country": user_info['country']
        }
    else:
        user_data = {}

    # Retrieve User's Recently Played Tracks
    response_recent = requests.get("https://api.spotify.com/v1/me/player/recently-played", headers=headers)
    recent_tracks = response_recent.json().get("items") if response_recent.status_code == 200 else []
    recent_track_data = [{
        "name": item['track']['name'],
        "artist": item['track']['artists'][0]['name'],
        "album": item['track']['album']['name'],
        "cover_url": item['track']['album']['images'][0]['url'],
        "played_at": "Day: " + datetime.fromisoformat(item['played_at'].replace("Z", "+00:00")).strftime('%Y-%m-%d') +
                     " Time: " + datetime.fromisoformat(item['played_at'].replace("Z", "+00:00")).strftime('%H:%M:%S')
    } for item in recent_tracks]

    # Retrieve User's Top Tracks
    response_top_tracks = requests.get("https://api.spotify.com/v1/me/top/tracks", headers=headers)
    top_tracks = response_top_tracks.json().get("items") if response_top_tracks.status_code == 200 else []
    top_track_data = [{
        "name": track['name'],
        "artist": track['artists'][0]['name'],
        "album": track['album']['name'],
        "cover_url": track['album']['images'][0]['url']
    } for track in top_tracks]

    # Retrieve User's Top Artists
    response_top_artists = requests.get("https://api.spotify.com/v1/me/top/artists", headers=headers)
    top_artists = response_top_artists.json().get("items") if response_top_artists.status_code == 200 else []
    top_artist_data = [{
        "name": artist['name'],
        "genres": ', '.join(artist['genres']),
        "followers": artist['followers']['total'],
        "image_url": artist['images'][0]['url'] if artist['images'] else None
    } for artist in top_artists]

    # Retrieve User's Saved Tracks
    response_saved_tracks = requests.get("https://api.spotify.com/v1/me/tracks", headers=headers)
    saved_tracks = response_saved_tracks.json().get("items") if response_saved_tracks.status_code == 200 else []
    saved_track_data = [{
        "name": track['track']['name'],
        "artist": track['track']['artists'][0]['name'],
        "album": track['track']['album']['name'],
        "cover_url": track['track']['album']['images'][0]['url']
    } for track in saved_tracks]

    # Retrieve User's Saved Albums
    response_saved_albums = requests.get("https://api.spotify.com/v1/me/albums", headers=headers)
    saved_albums = response_saved_albums.json().get("items") if response_saved_albums.status_code == 200 else []
    saved_album_data = [{
        "name": album['album']['name'],
        "artist": album['album']['artists'][0]['name'],
        "cover_url": album['album']['images'][0]['url']
    } for album in saved_albums]

    # Render the template with all the data
    return render_template("dashboard.html", 
                           user_name=user_data.get("display_name"),
                           user_profile_image=user_data.get("profile_image"),
                           user_country=user_data.get("country"),
                           user_followers=user_data.get("followers"),
                           recent_tracks=recent_track_data,
                           top_tracks=top_track_data,
                           top_artists=top_artist_data,
                           saved_tracks=saved_track_data,
                           saved_albums=saved_album_data)

@app.route('/logout')
def logout():
    print("Logging out...")  # Debugging print
    print("Access token before logout:", session.get("access_token"))  # Check if access token exists
    session.pop("access_token", None)  # Remove the access token from the session
    print("Access token after logout:", session.get("access_token"))  # Check if it's removed
    return redirect(url_for("login"))


if __name__ == "__main__":
    app.run(debug=True)



